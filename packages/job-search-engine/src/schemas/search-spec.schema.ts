import { z } from "zod";
import { PlatformSchema, UuidSchema } from "./user-profile.schema.js";
import { RemotePreferenceSchema, SeniorityLevelSchema } from "./normalized-profile.schema.js";

// ============================================================================
// SEARCH SPEC SCHEMA
// ============================================================================
// The SearchSpec is the output of the "Search Spec Generation" LLM stage.
// It defines the search parameters used to scrape jobs from LinkedIn/Upwork.
//
// INVARIANTS:
// - Generated by LLM from NormalizedProfile
// - MUST conform to strict JSON schema (LLM structured output)
// - Cached by profile_version (re-generated only when profile changes)
// - Contains keywords, filters, and preferences for job scraping
// - No free-form text (all fields have constraints)
// ============================================================================

/**
 * Keyword with optional weight for prioritization
 */
export const WeightedKeywordSchema = z.object({
  /** The keyword/phrase */
  keyword: z.string().min(1).max(100),
  /**
   * Importance weight (1-10)
   * Higher = more important in search
   */
  weight: z.number().int().min(1).max(10).default(5),
});

export type WeightedKeyword = z.infer<typeof WeightedKeywordSchema>;

/**
 * Location preference for job search
 */
export const LocationPreferenceSchema = z.object({
  /** Country code (ISO 3166-1 alpha-2) */
  country_code: z.string().length(2).nullable(),
  /** City name (optional) */
  city: z.string().max(100).nullable(),
  /** Region/state (optional) */
  region: z.string().max(100).nullable(),
});

export type LocationPreference = z.infer<typeof LocationPreferenceSchema>;

/**
 * Complete SearchSpec for job scraping
 *
 * INVARIANTS:
 * - profile_version MUST match source NormalizedProfile.profile_version
 * - title_keywords: 1-10 keywords for job title matching
 * - skill_keywords: 1-20 keywords for skill matching
 * - negative_keywords: 0-10 keywords to exclude
 * - At least one location OR remote_preference must be specified
 */
export const SearchSpecSchema = z.object({
  // ---- Identity ----
  user_id: UuidSchema,
  team_id: UuidSchema,

  // ---- Versioning ----
  /**
   * MUST match the source NormalizedProfile.profile_version.
   * SearchSpec is cached and only regenerated when this version changes.
   */
  profile_version: z.number().int().positive(),

  // ---- Title Keywords ----
  /**
   * Job title keywords to search for (e.g., "Full Stack Developer", "React Engineer")
   * LLM generates these based on user's experience and preferences.
   * Min 1, max 10 keywords.
   */
  title_keywords: z
    .array(WeightedKeywordSchema)
    .min(1, "At least one title keyword is required")
    .max(10, "Maximum 10 title keywords allowed"),

  // ---- Skill Keywords ----
  /**
   * Technical skill keywords to match (e.g., "typescript", "react", "nodejs")
   * Derived from user's primary and secondary skills.
   * Min 1, max 20 keywords.
   */
  skill_keywords: z
    .array(WeightedKeywordSchema)
    .min(1, "At least one skill keyword is required")
    .max(20, "Maximum 20 skill keywords allowed"),

  // ---- Negative Keywords ----
  /**
   * Keywords to EXCLUDE from search results (e.g., "unpaid", "equity only")
   * Optional, max 10.
   */
  negative_keywords: z
    .array(z.string().min(1).max(100))
    .max(10, "Maximum 10 negative keywords allowed")
    .default([]),

  // ---- Location Preferences ----
  /**
   * Preferred locations for jobs.
   * Empty array means no location preference (worldwide).
   */
  locations: z.array(LocationPreferenceSchema).max(5).default([]),

  // ---- Seniority Filter ----
  /**
   * Acceptable seniority levels.
   * Empty array means accept all levels.
   */
  seniority_levels: z.array(SeniorityLevelSchema).default([]),

  // ---- Remote Preference ----
  /**
   * Remote work preference for filtering.
   */
  remote_preference: RemotePreferenceSchema,

  // ---- Contract Type ----
  /**
   * Contract type to search for.
   */
  contract_types: z
    .array(z.enum(["freelance", "contract", "full_time", "part_time"]))
    .min(1)
    .default(["freelance", "contract"]),

  // ---- Platform-specific Filters ----
  /**
   * Platforms to search on.
   */
  platforms: z.array(PlatformSchema).min(1),

  // ---- Budget Filters ----
  /**
   * Minimum hourly rate filter (USD)
   */
  hourly_min: z.number().nonnegative().nullable(),

  /**
   * Maximum hourly rate filter (USD)
   */
  hourly_max: z.number().nonnegative().nullable(),

  /**
   * Minimum fixed budget filter (USD)
   */
  fixed_budget_min: z.number().nonnegative().nullable(),

  // ---- Search Limits ----
  /**
   * Maximum number of jobs to fetch per platform.
   * Default: 100, Max: 500
   */
  max_results_per_platform: z.number().int().min(10).max(500).default(100),

  // ---- Metadata ----
  /**
   * ISO8601 timestamp when this SearchSpec was generated.
   */
  generated_at: z.string().datetime(),
});

export type SearchSpec = z.infer<typeof SearchSpecSchema>;

// ============================================================================
// SEARCH SPEC VALIDATION REFINEMENTS
// ============================================================================

/**
 * SearchSpec with cross-field validations applied
 */
export const SearchSpecSchemaRefined = SearchSpecSchema.refine(
  (data) => {
    // At least one location OR remote preference must allow remote
    const hasLocation = data.locations.length > 0;
    const allowsRemote =
      data.remote_preference === "remote_only" ||
      data.remote_preference === "flexible";
    return hasLocation || allowsRemote;
  },
  {
    message: "Must specify at least one location or allow remote work",
    path: ["locations"],
  },
).refine(
  (data) => {
    // If hourly range is specified, min must be <= max
    if (data.hourly_min !== null && data.hourly_max !== null) {
      return data.hourly_min <= data.hourly_max;
    }
    return true;
  },
  {
    message: "hourly_min must be less than or equal to hourly_max",
    path: ["hourly_min"],
  },
);

// ============================================================================
// SEARCH SPEC CACHE KEY
// ============================================================================

/**
 * Generates a cache key for SearchSpec based on user and profile version.
 * SearchSpec is cached by (user_id, profile_version).
 */
export function getSearchSpecCacheKey(userId: string, profileVersion: number): string {
  return `search_spec:${userId}:v${profileVersion}`;
}
