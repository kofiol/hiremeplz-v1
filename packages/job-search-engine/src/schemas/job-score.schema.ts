import { z } from "zod";
import { UuidSchema } from "./user-profile.schema.js";

// ============================================================================
// JOB SCORE SCHEMA
// ============================================================================
// JobScore represents the LLM-generated match score between a job and user profile.
// This is the output of the "Job Scoring & Summary" stage.
//
// INVARIANTS:
// - Generated by LLM from (NormalizedJob + NormalizedProfile)
// - MUST conform to strict JSON schema (LLM structured output)
// - Stored with profile_version for staleness tracking
// - Multiple versions may exist for same job (one per profile_version)
// - Stale scores are HIDDEN from UI but NEVER deleted
// - Old scores preserved for debugging/analytics
// ============================================================================

/**
 * Match score 0-100
 * 0 = No match
 * 100 = Perfect match
 */
export const MatchScoreSchema = z.number().int().min(0).max(100);

export type MatchScore = z.infer<typeof MatchScoreSchema>;

/**
 * Individual scoring factor breakdown
 */
export const ScoreFactorSchema = z.object({
  /** Factor name (e.g., "skills_match", "experience_level") */
  factor: z.string().min(1).max(50),

  /** Score for this factor (0-100) */
  score: MatchScoreSchema,

  /** Weight of this factor in overall score (0-1) */
  weight: z.number().min(0).max(1),

  /** Brief explanation for this factor's score */
  reason: z.string().max(200).optional(),
});

export type ScoreFactor = z.infer<typeof ScoreFactorSchema>;

/**
 * Score breakdown with component scores
 *
 * INVARIANTS:
 * - Sum of (factor.score * factor.weight) should approximate overall score
 * - All factors are optional but standard factors should be present
 */
export const ScoreBreakdownSchema = z.object({
  /** Individual scoring factors */
  factors: z.array(ScoreFactorSchema).default([]),

  // ---- Standard Factors (for consistent evaluation) ----

  /** Skills match score (0-100) */
  skills_match: MatchScoreSchema.optional(),

  /** Experience level match (0-100) */
  experience_match: MatchScoreSchema.optional(),

  /** Budget/rate compatibility (0-100) */
  budget_match: MatchScoreSchema.optional(),

  /** Location/remote preference match (0-100) */
  location_match: MatchScoreSchema.optional(),

  /** Contract type match (0-100) */
  contract_match: MatchScoreSchema.optional(),

  /** Industry/domain relevance (0-100) */
  domain_match: MatchScoreSchema.optional(),
});

export type ScoreBreakdown = z.infer<typeof ScoreBreakdownSchema>;

/**
 * Reasoning bullet point for match explanation
 */
export const ReasoningPointSchema = z.object({
  /** Type: positive (pro), negative (con), or neutral */
  type: z.enum(["positive", "negative", "neutral"]),

  /** The reasoning point (max 150 chars) */
  text: z.string().min(1).max(150),
});

export type ReasoningPoint = z.infer<typeof ReasoningPointSchema>;

/**
 * JobScore - the complete scoring result for a job-profile pair
 *
 * Maps to `job_rankings` table in Supabase.
 *
 * INVARIANTS:
 * - (job_id, team_id, profile_version) uniquely identifies a score
 * - profile_version MUST match the profile version used for scoring
 * - Score is STALE if profile_version < user's current profile_version
 * - summary max 3 sentences
 * - reasoning max 5 bullet points
 */
export const JobScoreSchema = z.object({
  // ---- Identity ----
  /** Score record ID (from job_rankings.id) */
  id: UuidSchema.optional(),

  /** Team ID for multi-tenancy */
  team_id: UuidSchema,

  /** Reference to jobs.id */
  job_id: UuidSchema,

  /** Agent run that generated this score (optional) */
  agent_run_id: UuidSchema.nullable().optional(),

  // ---- Versioning (CRITICAL) ----
  /**
   * Profile version used when this score was computed.
   * Score is STALE if: profile_version < user.profile_version
   * Stale scores are hidden from UI and queued for recomputation.
   */
  profile_version: z.number().int().positive(),

  // ---- Matching Tightness ----
  /**
   * Tightness setting used for this score (1-5)
   * Different tightness levels may produce different scores for same job.
   */
  tightness: z.number().int().min(1).max(5),

  // ---- Score ----
  /**
   * Overall match score (0-100)
   * 0-20: Poor match
   * 21-40: Below average
   * 41-60: Average match
   * 61-80: Good match
   * 81-100: Excellent match
   */
  score: MatchScoreSchema,

  /**
   * Score breakdown by component
   */
  breakdown: ScoreBreakdownSchema,

  // ---- LLM-Generated Summary ----
  /**
   * Brief summary of why this job matches (or doesn't match)
   * Max 3 sentences, suitable for display in job card.
   */
  summary: z.string().max(500).optional(),

  /**
   * Bullet-point reasoning (max 5 points)
   * Shows pros and cons of the match.
   */
  reasoning: z.array(ReasoningPointSchema).max(5).default([]),

  // ---- Timestamps ----
  created_at: z.string().datetime().optional(),
});

export type JobScore = z.infer<typeof JobScoreSchema>;

// ============================================================================
// JOB SCORE CREATION (for LLM output)
// ============================================================================

/**
 * Schema for LLM-generated job score (before DB insertion)
 * This is what the LLM returns in structured output.
 */
export const JobScoreLLMOutputSchema = z.object({
  /** Overall match score (0-100) */
  score: MatchScoreSchema,

  /** Score breakdown by component */
  breakdown: ScoreBreakdownSchema,

  /** Brief summary (max 3 sentences) */
  summary: z.string().max(500),

  /** Bullet-point reasoning (max 5 points) */
  reasoning: z.array(ReasoningPointSchema).max(5),
});

export type JobScoreLLMOutput = z.infer<typeof JobScoreLLMOutputSchema>;

/**
 * Schema for creating a JobScore record
 */
export const JobScoreCreateSchema = JobScoreSchema.omit({
  id: true,
  created_at: true,
}).required({
  team_id: true,
  job_id: true,
  profile_version: true,
  tightness: true,
  score: true,
  breakdown: true,
});

export type JobScoreCreate = z.infer<typeof JobScoreCreateSchema>;

// ============================================================================
// JOB SCORE DISPLAY (for UI)
// ============================================================================

/**
 * JobScore with job details for display
 */
export const ScoredJobDisplaySchema = z.object({
  // Job fields
  job_id: UuidSchema,
  title: z.string(),
  company_name: z.string().nullable(),
  company_logo_url: z.string().url().nullable(),
  apply_url: z.string().url(),
  posted_at: z.string().datetime().nullable(),
  skills: z.array(z.string()),

  // Score fields
  score: MatchScoreSchema,
  summary: z.string().nullable(),
  reasoning: z.array(ReasoningPointSchema),

  // Staleness indicator
  is_stale: z.boolean(),
  profile_version: z.number().int().positive(),
});

export type ScoredJobDisplay = z.infer<typeof ScoredJobDisplaySchema>;

// ============================================================================
// JOB RANKINGS LATEST VIEW
// ============================================================================

/**
 * Schema matching the job_rankings_latest view
 * Returns the most recent score for each (job_id, tightness) pair
 */
export const JobRankingLatestSchema = z.object({
  job_id: UuidSchema,
  tightness: z.number().int().min(1).max(5),
  score: z.number(),
  breakdown: ScoreBreakdownSchema,
  created_at: z.string().datetime(),
});

export type JobRankingLatest = z.infer<typeof JobRankingLatestSchema>;

// ============================================================================
// VALIDATION REFINEMENTS
// ============================================================================

/**
 * Validate that breakdown factors sum approximately to overall score
 * (within Â±5 points tolerance)
 */
export const JobScoreSchemaRefined = JobScoreSchema.refine(
  (data) => {
    if (data.breakdown.factors.length === 0) return true;

    const weightedSum = data.breakdown.factors.reduce(
      (sum, factor) => sum + factor.score * factor.weight,
      0,
    );
    const totalWeight = data.breakdown.factors.reduce(
      (sum, factor) => sum + factor.weight,
      0,
    );

    // If no weights, skip validation
    if (totalWeight === 0) return true;

    const computedScore = Math.round(weightedSum / totalWeight);
    return Math.abs(computedScore - data.score) <= 5;
  },
  {
    message: "Breakdown factors should sum approximately to overall score",
    path: ["breakdown"],
  },
);
